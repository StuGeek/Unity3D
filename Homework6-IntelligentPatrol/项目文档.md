# 项目文档

## 项目基本信息

### 项目名称

智能巡逻兵 IntelligentPatrol

### 项目配置

#### 环境配置

+ Unity Hub版本：2.3.2
+ Unity版本：2020.1.0f1
+ Unity界面屏幕大小：710 x 389
+ 语言：C#
+ 操作系统：Win10
+ 编辑器：Visual Stdio Code

#### 项目配置过程

将`Assets`文件夹中覆盖创建的新项目的`Assets`文件夹，点击`Scene`文件夹中的`SampleScene`，再点击Play按钮即可运行。

#### 项目要求

+ 游戏设计要求：
  + 创建一个地图和若干巡逻兵(使用动画)；
  + 每个巡逻兵走一个3~5个边的凸多边型，位置数据是相对地址。即每次确定下一个目标位置，用自己当前位置为原点计算；
  + 巡逻兵碰撞到障碍物，则会自动选下一个点为目标；
  + 巡逻兵在设定范围内感知到玩家，会自动追击玩家；
  + 失去玩家目标后，继续巡逻；
  + 计分：玩家每次甩掉一个巡逻兵计一分，与巡逻兵碰撞游戏结束；
+ 程序设计要求：
  + 必须使用订阅与发布模式传消息
  + 工厂模式生产巡逻兵
+ 友善提示1：生成 3~5个边的凸多边型
  + 随机生成矩形
  + 在矩形每个边上随机找点，可得到 3 - 4 的凸多边型
  + 5 ?
+ 友善提示2：参考以前博客，给出自己新玩法

### 项目实现过程

#### 类图：

![1.png](./Image/1.png)

#### 单实例模板类

首先应该导入参考资源`Singleton`模板类：

```C#
public class Singleton<T> : MonoBehaviour where T : MonoBehaviour {
	protected static T instance;

	public static T Instance {
		get {
			if (instance == null) {
				instance = (T)FindObjectOfType (typeof(T));
				if (instance == null) {
					Debug.LogError ("An instance of " + typeof(T) +
					" is needed in the scene, but there is none.");
				}
			}
			return instance;
		}
	}
}
```

这个单实例模板类用来获得游戏场景中唯一的实例，用来保证工厂等对象在游戏场景中的唯一性。

**ScoreRecorder.cs：**

记分类中有一个分数成员变量，一个获取方法和一个加分方法：

```C#
public class ScoreController : MonoBehaviour {
    private int score = 0;  // 分数

    public int GetScore() {
        return score;
    }

    public void IncreaseScore() {
        score++;
    }
}
```

**SSAction.cs和SSActionManager.cs：**

`SSAction`是动作基类，`SSActionManager`是动作管理者的基类，其实现分别为：

```C#
public class SSAction : ScriptableObject {
    public bool enable = true;  // 动作可进行
    public bool destroy = false;  // 动作已完成可被销毁
    public GameObject gameobject { get; set; }  // 附着游戏对象
    public Transform transform { get; set; }  // 游戏对象的的运动
    public ISSActionCallback callback { get; set; }  // 回调函数

    public virtual void Start() {}  // Start()重写方法
    public virtual void Update() {}  // Update()重写方法
}

public class SSActionManager : MonoBehaviour, ISSActionCallback {
    // 动作集
    private Dictionary<int, SSAction> actions = new Dictionary<int, SSAction>();
    // 即将开始的动作的等待加入队列
    private List<SSAction> waitingAdd = new List<SSAction>();
    // 已完成的的动作的等待删除队列
    private List<int> waitingDelete = new List<int>();

    protected void Update() {
        // 载入即将开始的动作
        foreach (SSAction ac in waitingAdd) {
            actions[ac.GetInstanceID()] = ac;
        }
        // 清空等待加入队列
        waitingAdd.Clear();

        // 运行载入动作
        foreach (KeyValuePair<int, SSAction> kv in actions) {
            SSAction ac = kv.Value;
            if (ac.destroy) {
                waitingDelete.Add(ac.GetInstanceID());
            }
            else if (ac.enable) {
                ac.Update();
            }
        }

        // 清空已完成的动作
        foreach (int key in waitingDelete) {
            SSAction ac = actions[key];
            actions.Remove(key);
            Object.Destroy(ac);
        }
        // 清空等待删除队列
        waitingDelete.Clear();
    }

    // 初始化动作并加入到等待加入队列
    public void RunAction(GameObject gameobject, SSAction action, ISSActionCallback manager)
    {
        action.gameobject = gameobject;
        action.transform = gameobject.transform;
        action.callback = manager;
        waitingAdd.Add(action);
        action.Start();
    }

    // 巡逻兵正常巡逻或追踪玩家行为结束后的回调方法
    public void SSActionEvent(SSAction source,
        SSActionEventType events = SSActionEventType.Competed,
        int intParam = 0,
        string strParam = null,
        GameObject objectParam = null)
    {
        // 如果消息的回调参数为1，追踪行为结束，开始正常巡逻
        if(intParam == 1) {
            // 继续巡逻
            PatrolNormalAction move = PatrolNormalAction.GetSSAction(objectParam.gameObject.GetComponent<PatrolData>().startPos);
            this.RunAction(objectParam, move, this);
            // 玩家逃脱消息
            Singleton<GameEventManager>.Instance.PlayerGetAway();
        }
        // 如果消息的回调参数为0，正常巡逻结束，开始追踪玩家
        else {
            // 追踪玩家
            PatrolTrackAction trackAction = PatrolTrackAction.GetSSAction(objectParam.gameObject.GetComponent<PatrolData>().trackPlayer);
            this.RunAction(objectParam, trackAction, this);
        }
    }

    // 清除所有动作
    public void DestroyAll() {
        foreach (KeyValuePair<int, SSAction> kv in actions) {
            SSAction ac = kv.Value;
            ac.destroy = true;
        }
    }
}
```

**ISSActionCallback.cs：**

`ISSActionCallback`是巡逻兵正常巡逻或追踪玩家行为结束后的回调接口，当巡逻兵由正常巡逻转为追踪玩家，或由追踪玩家转为正常巡逻，就会调用这个接口里的`SSActionEvent`方法，开始新的行为和消息操作，由`SSActionManager`这个类继承：

```C#
public enum SSActionEventType : int { Started, Competed }
public interface ISSActionCallback {
    // 回调函数
    void SSActionEvent(SSAction source,
        SSActionEventType events = SSActionEventType.Competed,
        int intParam = 0,
        string strParam = null,
        Object objectParam = null);
}
```

**AreaTrigger.cs：**

`AreaTrigger`是地图中每个区域的触发方法，地图一共被分割成9个区域，每个区域有一个巡逻兵，当玩家进入某个区域时，区域会感知到玩家，并记录玩家进入区域的序号：

```C#
public class AreaTrigger : MonoBehaviour {
    public int areaId;  // 区域序号
    MainController mainController;
    private void Start() {
        mainController = Director.GetInstance().mainController as MainController;
    }

    void OnTriggerEnter(Collider collider) {
        // 记录玩家进入区域的序号
        if (collider.gameObject.tag == "Player") {
            mainController.SetPlayerAreaId(areaId);
        }
    }
}
```

**TreasureCollision.cs：**

`TreasureCollision`是宝箱的碰撞方法，当玩家碰撞到宝箱时，宝箱会从图中消失，并发送减少宝箱数量的消息：

```C#
public class TreasureCollision : MonoBehaviour {
    void OnTriggerEnter(Collider collider) {
        // 如果是玩家碰到还在显示中的宝箱
        if (collider.gameObject.tag == "Player" && this.gameObject.activeSelf) {
            this.gameObject.SetActive(false);
            // 减少宝箱数量
            Singleton<GameEventManager>.Instance.DecreaseTreasureNum();
        }
    }
}
```

**PlayerCollision.cs：**

`PlayerCollision`是巡逻兵与玩家碰撞的处理脚本，当巡逻兵感知到与其发生碰撞的对象是玩家，那么调整玩家状态，触发玩家被抓事件，如果碰撞是墙，那么根据刚体性质，改换方向移动：

```C#
public class PlayerCollision : MonoBehaviour {
    void OnCollisionEnter(Collision collider) {
        // 当和巡逻兵相撞的是玩家，那么调整玩家状态，触发玩家被抓事件，如果碰撞是墙，那么改换方向移动
        if (collider.gameObject.tag == "Player") {
            collider.gameObject.GetComponent<Animator>().SetTrigger("death");
            this.GetComponent<Animator>().SetTrigger("attack");
            Singleton<GameEventManager>.Instance.PlayerGetCaught();
        }
    }
}
```

**PatrolTrackAction.cs：**

`PatrolTrackAction`是巡逻兵的追踪方法，当玩家进入巡逻兵的感知范围内时，巡逻兵会使用这一方法，开始追踪玩家，如果玩家走出了巡逻兵的感知范围，则会发送追踪行为结束消息：

```C#
public class PatrolTrackAction : SSAction {
    private GameObject trackPlayer;  // 追踪的玩家
    private PatrolData patrol;  // 巡逻兵
    private MainController mainController;

    public override void Start() {
        patrol = this.gameobject.GetComponent<PatrolData>();
        mainController = Director.GetInstance().mainController;
    }

    public override void Update() {
        // 朝玩家方向走
        transform.position = Vector3.MoveTowards(this.transform.position, trackPlayer.transform.position, 2 * Time.deltaTime);
        this.transform.LookAt(trackPlayer.transform.position);

        // 如果玩家和巡逻兵不在同一个区域，或巡逻兵没有感知到玩家
        if (mainController.GetPlayerAreaId() != patrol.patrolAreaId || !patrol.isTrackPlayer) {
            // 发送追踪行为结束消息
            this.destroy = true;
            this.callback.SSActionEvent(this, SSActionEventType.Competed, 1, null, this.gameobject);
        }
    }

    // 获取动作
    public static PatrolTrackAction GetSSAction(GameObject player) {
        PatrolTrackAction action = CreateInstance<PatrolTrackAction>();
        action.trackPlayer = player;
        return action;
    }
}
```

**PatrolNormalAction.cs：**

`PatrolNormalAction`是巡逻兵的普通巡逻方法，巡逻兵按照一个矩形进行移动，如果玩家进入巡逻兵的感知范围，那么会发送普通巡逻行为结束消息：


```C#
public class PatrolNormalAction : SSAction {
    private Vector3 pos;  // 巡逻兵位置
    private float rectLength;  // 矩形长度
    public float speed = 1f;  // 移动速度
    private bool isDest;  // 是否每个方向的终点
    private int direction;  // 巡逻兵的移动方向
    private PatrolData patrol;  // 巡逻兵数据
    private MainController mainController;

    private const int EAST = 0;
    private const int NORTH = 1;
    private const int WEST = 2;
    private const int SOUTH = 3;
    
    // 获取动作
    public static PatrolNormalAction GetSSAction(Vector3 location) {
        PatrolNormalAction action = CreateInstance<PatrolNormalAction>();
        action.pos = new Vector3(location.x, 0, location.z);
        // 设定矩形边长
        action.rectLength = Random.Range(4, 8);
        return action;
    }

    public override void Start() {
        this.gameobject.GetComponent<Animator>().SetBool("run", true);
        patrol = this.gameobject.GetComponent<PatrolData>();
        mainController = Director.GetInstance().mainController;
        isDest = true;
        direction = EAST;
    }

    public override void Update() {
        // 巡逻兵按矩形移动
        MoveRect();
        // 如果巡逻兵和玩家在同一区域并在巡逻兵感知范围内，那么开始追踪
        if (mainController.GetPlayerAreaId() == patrol.patrolAreaId && patrol.isTrackPlayer) {
            this.destroy = true;
            this.callback.SSActionEvent(this, SSActionEventType.Competed, 0, null, this.gameobject);
        }
    }

    void MoveRect() {
        float newPosX = pos.x;
        float newPosZ = pos.z;
        if (isDest) {
            // 设定每个方向的新的移动终点
            switch (direction) {
                case EAST:
                    newPosX -= rectLength;
                    break;
                case NORTH:
                    newPosZ += rectLength;
                    break;
                case WEST:
                    newPosX += rectLength;
                    break;
                case SOUTH:
                    newPosZ -= rectLength;
                    break;
            }
            isDest = false;
        }
        Vector3 newPos = new Vector3(newPosX, 0, newPosZ);
        this.transform.LookAt(newPos);
        float distance = Vector3.Distance(transform.position, newPos);
        // 沿着方向直走
        if (distance > 1) {
            transform.position = Vector3.MoveTowards(this.transform.position, newPos, speed * Time.deltaTime);
        }
        // 在转弯处改变方向
        else {
            direction = (direction + 1) % 4;
            isDest = true;
        }
        // 设定新的位置
        pos.x = newPosX;
        pos.z = newPosZ;
    }
}
```

**PatrolData.cs：**

`PatrolData`是巡逻兵的模型，包含了巡逻兵相应的数据：

```C#
public class PatrolData : MonoBehaviour {
    public int patrolAreaId;  // 巡逻兵所在区域序号
    public bool isTrackPlayer = false;  // 是否跟随玩家
    public GameObject trackPlayer;  // 追踪的玩家对象
    public Vector3 startPos;  // 巡逻兵初始位置     
}
```

**PatrolTrigger.cs：**

`PatrolTrigger`是巡逻兵的触发方法，当玩家进入或退出巡逻兵的感知范围使，设置巡逻兵追踪玩家的状态和追踪玩家的对象：

```C#
public class PatrolTrigger : MonoBehaviour {
    void OnTriggerEnter(Collider collider) {
        // 如果玩家进入巡逻兵感知范围
        if (collider.gameObject.tag == "Player") {
            // 设置巡逻兵正在追踪玩家，设置追踪的玩家对象
            this.gameObject.transform.parent.GetComponent<PatrolData>().isTrackPlayer = true;
            this.gameObject.transform.parent.GetComponent<PatrolData>().trackPlayer = collider.gameObject;
        }
    }

    void OnTriggerExit(Collider collider) {
        // 如果玩家退出巡逻兵感知范围
        if (collider.gameObject.tag == "Player") {
            // 设置巡逻兵不在追踪玩家，设置追踪的玩家对象为空
            this.gameObject.transform.parent.GetComponent<PatrolData>().isTrackPlayer = false;
            this.gameObject.transform.parent.GetComponent<PatrolData>().trackPlayer = null;
        }
    }
}
```

**PatrolMoveManager.cs：**

`PatrolMoveManager`是巡逻兵的移动方法管理器，里面有一个按照矩形移动的方法：

```C#
public class PatrolMoveManager : SSActionManager {
    // 按照矩形移动
    public void MoveRect(GameObject patrol) {
        PatrolNormalAction moveRect = PatrolNormalAction.GetSSAction(patrol.transform.position);
        this.RunAction(patrol, moveRect, this);
    }
}
```

**MainController.cs：**

主控制类`MainController`的代码如下：

```C#
public class MainController : MonoBehaviour {
    private ScoreController scoreRecorder;  // 记分器
    private PatrolMoveManager moveManager;  // 移动管理器
    private int playerAreaId;  // 玩家所处区域序号
    private GameObject player;  // 玩家对象
    public Camera mainCamera;  // 主相机
    public int treasureNumber = 10;  // 宝箱数量
    public float moveSpeed = 5;  // 移动速度
    public float rotateSpeed = 135f;  // 旋转速度
    private bool isGameOver;  // 游戏是否结束
    
    void Start() {
        Director director = Director.GetInstance();
        director.mainController = this;
        scoreRecorder = gameObject.AddComponent<ScoreController>() as ScoreController;
        moveManager = gameObject.AddComponent<PatrolMoveManager>() as PatrolMoveManager;
        LoadResources();
        mainCamera.GetComponent<CameraFollow>().follow = player;
        isGameOver = false;
    }

    void Update() {
        CheckGameOver();
    }

    // 加载资源
    public void LoadResources() {
        // 生成地图
        Instantiate(Resources.Load<GameObject>("Prefabs/Map"));
        // 生成玩家
        player = Instantiate(Resources.Load("Prefabs/Player"), new Vector3(0, 9, 0), Quaternion.identity) as GameObject;
        // 生成宝箱
        Singleton<GameObjectFactory>.Instance.GetTreasures();
        // 生成巡逻兵并让其移动
        MovePatrol();
    }

    public void MovePatrol() {
        // 让所有巡逻兵都移动
        List<GameObject> patrols = Singleton<GameObjectFactory>.Instance.GetPatrols();
        for (int i = 0; i < patrols.Count; i++) {
            moveManager.MoveRect(patrols[i]);
        }
    }

    // 玩家移动
    public void MovePlayer(float translationX, float translationZ) {
        if(!isGameOver) {
            MovePlayerAction(translationX, translationZ);
            if (player.transform.position.y != 0) {
                player.transform.position = new Vector3(player.transform.position.x, 0, player.transform.position.z);
            }     
        }
    }

    // 设置玩家移动时的跑步动作
    public void MovePlayerAction(float translationX, float translationZ) {
        if (translationX != 0 || translationZ != 0) {
            player.GetComponent<Animator>().SetBool("run", true);
        }
        else {
            player.GetComponent<Animator>().SetBool("run", false);
        }
        // 移动和旋转动作
        player.transform.Translate(0, 0, translationZ * moveSpeed * Time.deltaTime);
        player.transform.Rotate(0, translationX * rotateSpeed * Time.deltaTime, 0);
    }

    public void IncreaseScore() {
        scoreRecorder.IncreaseScore();
    }

    public void CheckGameOver() {
        // 所有宝箱都被收集，游戏结束
        if(treasureNumber == 0) {
            Gameover();
        }
    }

    // 游戏结束，释放所有的巡逻兵
    public void Gameover() {
        isGameOver = true;
        Singleton<GameObjectFactory>.Instance.FreePatrols();
        moveManager.DestroyAll();
    }

    public void DecreaseTreasureNumber() {
        treasureNumber--;
    }

    public int GetScore() {
        return scoreRecorder.GetScore();
    }

    public void SetPlayerAreaId(int areaId) {
        playerAreaId = areaId;
    }

    public int GetPlayerAreaId() {
        return playerAreaId;
    }

    public int GetTreasureNumber() {
        return treasureNumber;
    }

    public bool GetGameover() {
        return isGameOver;
    }

    public void Restart() {
        SceneManager.LoadScene("Scenes/SampleSence");
    }

    void OnEnable() {
        GameEventManager.AddScoreAction += IncreaseScore;
        GameEventManager.GameoverAction += Gameover;
        GameEventManager.DecreaseTreasureAction += DecreaseTreasureNumber;
    }

    void OnDisable() {
        GameEventManager.AddScoreAction -= IncreaseScore;
        GameEventManager.GameoverAction -= Gameover;
        GameEventManager.DecreaseTreasureAction -= DecreaseTreasureNumber;
    }
}
```

**CameraFollow.cs：**

`CameraFollow`是摄像机跟随脚本，摄像机可以跟随玩家移动，提高可玩性：

```C#
public class CameraFollow : MonoBehaviour {
    public GameObject follow;  // 跟随的物体
    public float speed = 5f;  // 相机跟随物体的的速度
    Vector3 offsetPos;  // 相机和物体的相对偏移位置

    void Start() {
        offsetPos = transform.position - follow.transform.position;
    }

    void FixedUpdate() {
        Vector3 targetPos = follow.transform.position + offsetPos;
        // 摄像机平滑过渡到目标位置
        transform.position = Vector3.Lerp(transform.position, targetPos, speed * Time.deltaTime);
    }
}
```

**View.cs：**

视图类经过主控制器的控制，显示相应内容：

```C#

public class View : MonoBehaviour {
    private MainController mainController;

    void Start() {
        mainController = Director.GetInstance().mainController as MainController;
    }

    void Update() {
        Move();
    }

    void OnGUI() {
        ShowScore();
        ShowRules();
        GUIStyle textStyle = new GUIStyle();
        textStyle.fontSize = 30;
        if(mainController.GetGameover() && mainController.GetTreasureNumber() != 0) {
            GUI.Label(new Rect(Screen.width / 2 - 55, Screen.width / 2 - 250, 100, 100), "游戏结束", textStyle);
            if (GUI.Button(new Rect(Screen.width / 2 - 45, Screen.width / 2 - 170, 100, 50), "重新开始")) {
                mainController.Restart();
            }
        }
        else if(mainController.GetTreasureNumber() == 0) {
            GUI.Label(new Rect(Screen.width / 2 - 55, Screen.width / 2 - 250, 100, 100), "恭喜胜利！", textStyle);
            if (GUI.Button(new Rect(Screen.width / 2 - 45, Screen.width / 2 - 170, 100, 50), "重新开始")) {
                mainController.Restart();
            }
        }
    }

    public void Move() {
        float translationX = Input.GetAxis("Horizontal");
        float translationZ = Input.GetAxis("Vertical");
        mainController.MovePlayer(translationX, translationZ);
    }

    public void ShowScore() {
        GUIStyle scoreStyle = new GUIStyle();
        GUIStyle textStyle = new GUIStyle();
        scoreStyle.normal.textColor = Color.yellow;
        scoreStyle.fontSize = 20;
        textStyle.fontSize = 20;
        GUI.Label(new Rect(Screen.width - 100, 5, 200, 50), "分数:", textStyle);
        GUI.Label(new Rect(Screen.width - 50, 5, 200, 50), mainController.GetScore().ToString(), scoreStyle);
        GUI.Label(new Rect(10, 5, 50, 50), "剩余宝箱数:", textStyle);
        GUI.Label(new Rect(125, 5, 50, 50), mainController.GetTreasureNumber().ToString(), scoreStyle);
    }

    // 展示规则
    public void ShowRules() {
        GUIStyle ruleStyle = new GUIStyle();
        ruleStyle.fontSize = 17;
        GUI.Label(new Rect(Screen.width / 2 - 80, 10, 100, 100), "按方向键进行移动", ruleStyle);
        GUI.Label(new Rect(Screen.width / 2 - 190, 30, 100, 100), "每次甩掉一个巡逻兵计一分，与巡逻兵碰撞游戏结束", ruleStyle);
        GUI.Label(new Rect(Screen.width / 2 - 130, 50, 100, 100), "收集完所有的宝箱那么游戏获胜", ruleStyle);
    }
}
```

#### 飞碟对象和游戏状态相关部分

然后实现图中负责游戏每轮飞碟的创建和销毁，记录得分和游戏状态的这一部分：

![2.png](./Image/2.png)

可以根据参考网站上的类图示例来实现：

![3.png](./Image/3.png)

**DiskFactory.cs：**

飞碟工厂类负责飞碟对象的创建和销毁，其在场景中是单实例的，且使用了对象池，实现了缓存功能，当一个飞碟对象被创建时，会首先在对象池中寻找没有被使用的空闲飞碟对象，有的话就根据规则设置飞碟对象相应属性后直接使用，没有再创建，这样就省下了一部分开销，销毁则直接将飞碟对象加入对象池的空闲部分，下次要使用时直接拿出即可，实现如下：

```C#
public class DiskFactory : MonoBehaviour {
    public GameObject diskPrefab; // 飞碟游戏对象，创建新的飞碟游戏对象的复制对象
    private List<DiskData> used; // 正在被游戏使用的飞碟对象
    private List<DiskData> free; // 没有被使用的空闲飞碟对象

    public void Start() {
        diskPrefab = GameObject.Instantiate(Resources.Load<GameObject>("Prefabs/Disk"), Vector3.zero, Quaternion.identity);
        diskPrefab.SetActive(false);
        used = new List<DiskData>();
        free = new List<DiskData>();
    }

    // 飞碟获取方法，根据ruler获取相应飞碟
    public GameObject GetDisk(Ruler ruler) {
        GameObject disk;

        // 从缓存中获取飞碟，没有则先创建
        int diskNum = free.Count;
        if (diskNum == 0) {
            disk = GameObject.Instantiate(diskPrefab, Vector3.zero, Quaternion.identity);
            disk.AddComponent(typeof(DiskData));
        }
        else {
            disk = free[diskNum - 1].gameObject;
            free.Remove(free[diskNum - 1]);
        }

        // 根据ruler设置disk的速度、颜色、大小、飞入方向
        disk.GetComponent<DiskData>().speed = ruler.speed;
        disk.GetComponent<DiskData>().color = ruler.color;
        disk.GetComponent<DiskData>().size = ruler.size;
        
        // 给飞碟上颜色
        if (ruler.color == "red") {
            disk.GetComponent<Renderer>().material.color = Color.red;
        }
        else if (ruler.color == "green") {
            disk.GetComponent<Renderer>().material.color = Color.green;
        }
        else {
            disk.GetComponent<Renderer>().material.color = Color.blue;
        }

        // 绘制飞碟大小
        disk.transform.localScale = new Vector3(1.2f, 0.1f * (float)ruler.size, 1.2f);
        
        // 选择飞碟飞入屏幕的起始位置
        disk.transform.position = ruler.beginPos;
        
        // 设置飞碟显示
        disk.SetActive(true);
    
        // 将飞碟加入使用队列
        used.Add(disk.GetComponent<DiskData>());

        return disk;
    }

    // 飞碟回收方法，将不使用的飞碟从使用队列放到空闲队列中
    public void FreeDisk(GameObject disk) {
        foreach (DiskData d in used) {
            if (d.gameObject.GetInstanceID() == disk.GetInstanceID()) {
                disk.SetActive(false);
                used.Remove(d);
                free.Add(d);
                break;
            }

        }
    }
}
```

`disk:GameObject`是飞碟的预制，需要提前制作好，并加上刚体组件`Rigidbody`，将`Use Gravity`项勾选上：

![4.png](./Image/4.png)

**DiskData.cs：**

`DiskData`是飞碟的模型，包含了飞碟相应的数据：

```C#
public class DiskData : MonoBehaviour {
    public int size; // 大小
    public string color; // 颜色
    public int speed; // 发射速度
}
```

这样就使用工厂方法 + 单实例 + 对象池完成了飞碟的创建和销毁，实现要求。

**RoundController.cs：**

回合控制器控制飞碟对象的运动类型为运动学运动或物理运动，并根据一定规则请求飞碟工厂生成相应的飞碟对象，控制游戏飞碟对象的发射和轮次的进行，实现如下：

```C#
public class RoundController : MonoBehaviour {
    private IActionManager actionManager; // 选择飞碟的运动类型
    private ScoreRecorder scoreRecorder; // 记分器
    private MainController mainController;
    private Ruler ruler; // 飞碟获取规则

    void Start() {
        // 一开始飞碟的运动类型默认为运动学运动
        actionManager = gameObject.AddComponent<CCActionManager>();
        gameObject.AddComponent<PhysisActionManager>();
        scoreRecorder = new ScoreRecorder();
        mainController = Director.GetInstance().mainController;
        gameObject.AddComponent<DiskFactory>();
        InitRuler();
    }

    void InitRuler() {
        ruler.trialNum = 0;
        ruler.roundNum = 0;
        ruler.sendTime = 0;
        ruler.roundDisksNum = new int [10];
        generateRoundDisksNum();
    }

    // 生成每trial同时发出的飞碟数量的数组，同时发出飞碟个数不超过4
    public void generateRoundDisksNum() {
        for (int i = 0; i < 10; ++i) {
            ruler.roundDisksNum[i] = Random.Range(0, 4) + 1;
        }
    }

    public void Reset() {
        InitRuler();
        scoreRecorder.Reset();
    }

    public void Record(DiskData disk) {
        scoreRecorder.Record(disk);
    }

    public int GetScores() {
        return scoreRecorder.score;
    }

    public void SetRoundSum(int roundSum) {
        ruler.roundSum = roundSum;
    }

    // 设置游戏模式，同时支持物理运动模式和动力学运动模式
    public void SetPlayDiskModeToPhysis(bool isPhysis) {
        if (isPhysis) {
            actionManager = Singleton<PhysisActionManager>.Instance as IActionManager;
        }
        else {
            actionManager = Singleton<CCActionManager>.Instance as IActionManager;
        }
    }

    // 发射飞碟
    public void LaunchDisk() {
        // 使飞碟飞入位置尽可能分开，从不同位置飞入使用的数组
        int [] beginPosY = new int [4]{0, 0, 0, 0};

        for (int i = 0; i < ruler.roundDisksNum[ruler.trialNum]; ++i) {
            // 获取随机数
            int randomNum = Random.Range(0, 3) + 1;
            // 飞碟速度随回合数增加而变快，这样难度增加
            ruler.speed = randomNum * (ruler.roundNum + 4);

            // 重新选取随机数，并根据随机数选择飞碟颜色
            randomNum = Random.Range(0, 3) + 1;
            if (randomNum == 1) {
                ruler.color = "red";
            }
            else if (randomNum == 2) {
                ruler.color = "green";
            }
            else {
                ruler.color = "blue";
            }

            // 重新选取随机数，并根据随机数选择飞碟的大小
            ruler.size = Random.Range(0, 3) + 1;

            // 重新选取随机数，并根据随机数选择飞碟飞入的方向
            randomNum = Random.Range(0, 2);
            if (randomNum == 1) {
                ruler.direction = new Vector3(3, 1, 0);
            }
            else {
                ruler.direction = new Vector3(-3, 1, 0);
            }

            // 重新选取随机数，并使不同飞碟的飞入位置尽可能分开
            do {
                randomNum = Random.Range(0, 4);
            } while (beginPosY[randomNum] != 0);
            beginPosY[randomNum] = 1;
            ruler.beginPos = new Vector3(-ruler.direction.x * 4, -0.5f * randomNum, 0);

            // 根据ruler从工厂中生成一个飞碟
            GameObject disk = Singleton<DiskFactory>.Instance.GetDisk(ruler);
        
            // 设置飞碟的飞行动作
            actionManager.PlayDisk(disk, ruler.speed, ruler.direction);
        }
    }

    // 释放工厂飞碟
    public void FreeFactoryDisk(GameObject disk) {
        Singleton<DiskFactory>.Instance.FreeDisk(disk);
    }

    // 释放所有工厂飞碟
    public void FreeAllFactoryDisk() {
        GameObject[] obj = FindObjectsOfType(typeof(GameObject)) as GameObject[];
        foreach (GameObject g in obj) {
            if (g.gameObject.name == "Disk(Clone)(Clone)") {
                Singleton<DiskFactory>.Instance.FreeDisk(g);
            }
        }
    }

    void Update() {
        if (mainController.GetGameState() == (int)GameState.Playing) {
            ruler.sendTime += Time.deltaTime;
            // 每隔2s发送一次飞碟(trial)
            if (ruler.sendTime > 2) {
                ruler.sendTime = 0;
                // 如果为无限回合或还未到设定回合数
                if (ruler.roundSum == -1 || ruler.roundNum < ruler.roundSum) {
                    // 发射飞碟，次数trial增加
                    mainController.SetViewTip("");
                    LaunchDisk();
                    ruler.trialNum++;
                    // 当次数trial等于10时，说明一个回合已经结束，回合加一，重新生成飞碟数组
                    if (ruler.trialNum == 10) {
                        ruler.trialNum = 0;
                        ruler.roundNum++;
                        generateRoundDisksNum();
                    }
                }
                // 否则游戏结束，提示重新进行游戏
                else {
                    mainController.SetViewTip("Click Restart and Play Again!");
                    mainController.SetGameState((int)GameState.GameOver);
                }
                // 设置回合数和trial数目的提示
                if (ruler.trialNum == 0) mainController.SetViewRoundNum(ruler.roundNum);
                else mainController.SetViewRoundNum(ruler.roundNum + 1);
                mainController.SetViewTrialNum(ruler.trialNum);
            }
        }
    }
}
```

`Ruler`为飞碟规则：

```C#
// 飞碟获取规则
public struct Ruler {
    public int trialNum; // 当前trial的编号
    public int roundNum; // 当前round的编号
    public int roundSum; // 一共round的总数目
    public int [] roundDisksNum; // 每一轮对于trial的飞碟数量
    public float sendTime; // 发射间隔时间

    public int size; // 飞碟大小
    public int speed; // 飞碟速度
    public string color; // 飞碟颜色
    public Vector3 direction; // 飞碟飞入方向
    public Vector3 beginPos; // 飞碟飞入位置
};
```

#### 飞碟动作部分

接着实现图中负责飞碟运动动作的这一部分：

![5.png](./Image/5.png)

飞碟的运动类型有运动学运动和物理运动两种类型，可以根据参考网站上的类图示例使用适配器模式来实现：

![6.png](./Image/6.png)

**IActionManager.cs：**

`IActionManager`是飞碟运动类型动作的管理接口，里面有一个方法`PlayDisk`，由`CCActionManager`和`PhysisActionManager`两个适配器类分别实现，描述飞碟的不同运动过程，实现如下：

``` C#
public interface IActionManager {
    void PlayDisk(GameObject disk, float speed, Vector3 direction);
}
```

**ISSActionCallback.cs：**

`ISSActionCallback`是飞碟运动完成后的回调接口，当飞碟飞行完成之后，就会调用这个接口里的`SSActionEvent`方法，完成对飞碟对象的销毁，由`CCActionManager`和`PhysisActionManager`两个适配器类继承：

```C#
public enum SSActionEventType : int { Started, Competed }
public interface ISSActionCallback {
    // 回调函数
    void SSActionEvent(SSAction source,
        SSActionEventType events = SSActionEventType.Competed,
        int intParam = 0,
        string strParam = null,
        Object objectParam = null);
}
```

**CCActionManager.cs和PhysisActionManager.cs：**

这两个类是运动学运动动作和物理运动动作的管理类，分别实现了继承的`IActionManager`接口中的`PlayDisk`方法，也实现了继承的`ISSActionCallback`这个接口中的回调方法`SSActionEvent`，实现如下：

```C#
public class CCActionManager : SSActionManager, ISSActionCallback, IActionManager {
    CCPlayDiskAction PlayDiskAction; // 飞碟空中动作

    public void PlayDisk(GameObject disk, float speed, Vector3 direction) {
        PlayDiskAction = CCPlayDiskAction.GetSSAction(direction, speed);
        RunAction(disk, PlayDiskAction, this);
    }

    // 回调函数
    public void SSActionEvent(SSAction source,
    SSActionEventType events = SSActionEventType.Competed,
    int intParam = 0,
    string strParam = null,
    Object objectParam = null)
    {
        // 结束飞行后回收飞碟
        Singleton<RoundController>.Instance.FreeFactoryDisk(source.gameObject);
    }
}

public class PhysisActionManager : SSActionManager, ISSActionCallback, IActionManager {
    PhysisPlayDiskAction PlayDiskAction; // 飞碟空中动作

    public void PlayDisk(GameObject disk, float speed, Vector3 direction) {
        PlayDiskAction = PhysisPlayDiskAction.GetSSAction(direction, speed);
        RunAction(disk, PlayDiskAction, this);
    }

    // 回调函数
    public void SSActionEvent(SSAction source,
    SSActionEventType events = SSActionEventType.Competed,
    int intParam = 0,
    string strParam = null,
    Object objectParam = null)
    {
        // 结束飞行后回收飞碟
        Singleton<RoundController>.Instance.FreeFactoryDisk(source.gameObject);
    }
}
```

**CCPlayDiskAction.cs和PhysisPlayDiskAction.cs：**

这两个类是运动学运动动作和物理运动动作的类，分别实现了继承的`SSAction`接口中的`Start`和`Update`方法，实现如下：

```C#
public class CCPlayDiskAction : SSAction {
    float gravity; // 垂直速度
    float speed; // 水平速度
    Vector3 direction;  // 方向
    float time; // 时间

    public static CCPlayDiskAction GetSSAction(Vector3 direction, float speed) {
        CCPlayDiskAction action = ScriptableObject.CreateInstance<CCPlayDiskAction>();
        action.gravity = 9.8f;
        action.time = 0;
        action.speed = speed;
        action.direction = direction;
        return action;
    }

    public override void Start() {
        gameObject.GetComponent<Rigidbody>().isKinematic = true;
    }

    public override void Update() {
        time += Time.deltaTime;
        transform.Translate(Vector3.down * gravity * time * Time.deltaTime);
        transform.Translate(direction * speed * Time.deltaTime);
        // 飞碟到达底部动作结束，回调
        if (this.transform.position.y < -5) {
            this.destroy = true;
            this.enable = false;
            this.callback.SSActionEvent(this);
        }
    }
}

public class PhysisPlayDiskAction : SSAction {
    float speed; // 水平速度
    Vector3 direction; // 飞行方向

    public static PhysisPlayDiskAction GetSSAction(Vector3 direction, float speed) {
        PhysisPlayDiskAction action = ScriptableObject.CreateInstance<PhysisPlayDiskAction>();
        action.speed = speed;
        action.direction = direction;
        return action;
    }

    public override void Start() {
        gameObject.GetComponent<Rigidbody>().isKinematic = false;
        // 水平初速度
        gameObject.GetComponent<Rigidbody>().velocity = speed * direction;
    }

    public override void Update() {
        // 飞碟到达底部动作结束，回调
        if (this.transform.position.y < -5) {
            this.destroy = true;
            this.enable = false;
            this.callback.SSActionEvent(this);
        }
    }
}
```

#### 主控制类和视图部分

最后实现图中控制回合控制器的主控制器及其控制的视图部分：

![7.png](./Image/7.png)

**MainController.cs：**

主控制类MainController负责控制回合控制器以及游戏视图，回合控制器`RoundController`监测游戏事件发生之后，通知主控制器`MainController`，然后主控制器控制游戏视图`View`类显示相应内容，通过设置主控制类中的成员变量N，可以调整普通模式的默认回合，代码如下：

```C#
/* 游戏状态，0为准备进行，1为正在进行游戏，2为结束 */
enum GameState {
    Ready = 0, Playing = 1, GameOver = 2
};

public class MainController : MonoBehaviour {
    private RoundController roundController; // 回合控制器
    private View view; // 游戏视图
    private int N = 2; // 默认游戏回合
    private int gameState;
    public GUISkin gameSkin;

    void Start() {
        Director.GetInstance().mainController = this;
        roundController = gameObject.AddComponent<RoundController>();
        view = gameObject.AddComponent<View>();
        gameState = (int)GameState.Ready;
        view.gameSkin = gameSkin;
    }

    public int GetN() {
        return N;
    }

    public void Restart() {
        view.Init();
        roundController.Reset();
    }

    public void SetGameState(int state) {
        gameState = state;
    }

    public int GetGameState() {
        return gameState;
    }

    public void ShowPage() {
        switch(gameState) {
            case 0:
                view.ShowHomePage();
                break;
            case 1:
                view.ShowGamePage();
                break;
            case 2:
                view.ShowRestart();
                break;
        }
    }

    public void SetRoundSum(int roundSum) {
        roundController.SetRoundSum(roundSum);
    }

    public void SetPlayDiskModeToPhysis(bool isPhysis) {
        roundController.SetPlayDiskModeToPhysis(isPhysis);
    }

    public void SetViewTip(string tip) {
        view.SetTip(tip);
    }

    public void SetViewScore(int score) {
        view.SetScore(score);
    }

    public void SetViewRoundNum(int round) {
        view.SetRoundNum(round);
    }

    public void SetViewTrialNum(int trial) {
        view.SetTrialNum(trial);
    }

    public void Hit(Vector3 position) {
        Camera camera = Camera.main;
        Ray ray = camera.ScreenPointToRay(position);

        RaycastHit[] hits;
        hits = Physics.RaycastAll(ray);

        for (int i = 0; i < hits.Length; i++) {
            RaycastHit hit = hits[i];
            if (hit.collider.gameObject.GetComponent<DiskData>() != null) {
                // 把击中的飞碟移出屏幕，触发回调释放
                hit.collider.gameObject.transform.position = new Vector3(0, -6, 0);
                // 记录飞碟得分
                roundController.Record(hit.collider.gameObject.GetComponent<DiskData>());
                // 显示当前得分
                view.SetScore(roundController.GetScores());
            }
        }
    }

    // 释放所有工厂飞碟
    public void FreeAllFactoryDisk() {
        roundController.FreeAllFactoryDisk();
    }
}
```

**View.cs：**

视图类经过主控制器的控制，显示相应内容：

```C#
public class View : MonoBehaviour {
    private MainController mainController;
    private int score;
    private string tip;
    private string roundNum;
    private string trialNum;
    public GUISkin gameSkin;  // 游戏控件的皮肤风格

    void Start() {
        score = 0;
        tip = "";
        roundNum = "";
        trialNum = "";
        mainController = Director.GetInstance().mainController;
    }

    public void SetTip(string tip) {
        this.tip = tip;
    }

    public void SetScore(int score) {
        this.score = score;
    }

    public void SetRoundNum(int round) {
        roundNum = "回合: " + round;
    }

    public void SetTrialNum(int trial) {
        if (trial == 0) trial = 10;
        trialNum = "Trial: " + trial;
    }

    public void Init() {
        score = 0;
        tip = "";
        roundNum = "";
        trialNum = "";
    }

    public void AddTitle() {
        GUIStyle titleStyle = new GUIStyle();
        titleStyle.normal.textColor = Color.black;
        titleStyle.fontSize = 50;

        GUI.Label(new Rect(Screen.width / 2 - 80, 20, 60, 100), "Hit UFO", titleStyle);
    }

    public void AddChooseModeButton() {
        GUI.skin = gameSkin;
        if (GUI.Button(new Rect(280, 100, 160, 80), "普通模式\n(默认为" + mainController.GetN() + "回合)")) {
            mainController.SetRoundSum(mainController.GetN());
            mainController.Restart();
            mainController.SetGameState((int)GameState.Playing);
        }
        if (GUI.Button(new Rect(280, 210, 160, 80), "无尽模式\n(回合数无限)")) {
            mainController.SetRoundSum(-1);
            mainController.Restart();
            mainController.SetGameState((int)GameState.Playing);
        }
    }

    public void ShowHomePage() {
        AddChooseModeButton();
    }

    public void AddActionModeButton() {
        GUI.skin = gameSkin;
        if (GUI.Button(new Rect(10, Screen.height - 100, 110, 40), "运动学模式")) {
            mainController.FreeAllFactoryDisk();
            mainController.SetPlayDiskModeToPhysis(false);
        }
        if (GUI.Button(new Rect(10, Screen.height - 50, 110, 40), "物理模式")) {
            mainController.FreeAllFactoryDisk();
            mainController.SetPlayDiskModeToPhysis(true);
        }
    }

    public void AddBackButton() {
        GUI.skin = gameSkin;
        if (GUI.Button(new Rect(10, 10, 60, 40), "Back")) {
            mainController.FreeAllFactoryDisk();
            mainController.Restart();
            mainController.SetGameState((int)GameState.Ready);
        }
    }

    public void AddGameLabel() {
        GUIStyle labelStyle = new GUIStyle();
        labelStyle.normal.textColor = Color.black;
        labelStyle.fontSize = 30;

        GUI.Label(new Rect(570, 10, 100, 50), "得分: " + score, labelStyle);
        GUI.Label(new Rect(170, 80, 50, 200), tip, labelStyle);
        GUI.Label(new Rect(570, 60, 100, 50), roundNum, labelStyle);
        GUI.Label(new Rect(570, 110, 100, 50), trialNum, labelStyle);
    }

    public void AddRestartButton() {
        if (GUI.Button(new Rect(300, 150, 100, 60), "Restart")) {
            mainController.FreeAllFactoryDisk();
            mainController.Restart();
            mainController.SetGameState((int)GameState.Playing);
        }
    }

    public void ShowGamePage() {
        AddGameLabel();
        AddBackButton();
        AddActionModeButton();
        if (Input.GetButtonDown("Fire1")) {
            mainController.Hit(Input.mousePosition);
        }
    }

    public void ShowRestart() {
        ShowGamePage();
        AddRestartButton();
    }

    void OnGUI() {
        AddTitle();
        mainController.ShowPage();
    }
}
```

**Director.cs：**

导演类，返回主控制器的唯一实例：

```C#
public class Director : System.Object {
    private static Director instance;
    public MainController mainController { get; set; }
    public static Director GetInstance() {
        if (instance == null) {
            instance = new Director();
        }
        return instance;
    }
}
```

### 核心算法

在`RoundController`的`LaunchDisk`方法中，飞碟以随机方式进行发射，因为要求随着回合往后难度增大，所以这里设置了飞碟的速度随回合的增加而增大，表现难度增加：

```C#
// 发射飞碟
public void LaunchDisk() {
    // 使飞碟飞入位置尽可能分开，从不同位置飞入使用的数组
    int [] beginPosY = new int [4]{0, 0, 0, 0};

    for (int i = 0; i < ruler.roundDisksNum[ruler.trialNum]; ++i) {
        // 获取随机数
        int randomNum = Random.Range(0, 3) + 1;
        // 飞碟速度随回合数增加而变快，这样难度增加
        ruler.speed = randomNum * (ruler.roundNum + 4);

        // 重新选取随机数，并根据随机数选择飞碟颜色
        randomNum = Random.Range(0, 3) + 1;
        if (randomNum == 1) {
            ruler.color = "red";
        }
        else if (randomNum == 2) {
            ruler.color = "green";
        }
        else {
            ruler.color = "blue";
        }

        // 重新选取随机数，并根据随机数选择飞碟的大小
        ruler.size = Random.Range(0, 3) + 1;

        // 重新选取随机数，并根据随机数选择飞碟飞入的方向
        randomNum = Random.Range(0, 2);
        if (randomNum == 1) {
            ruler.direction = new Vector3(3, 1, 0);
        }
        else {
            ruler.direction = new Vector3(-3, 1, 0);
        }

        // 重新选取随机数，并使不同飞碟的飞入位置尽可能分开
        do {
            randomNum = Random.Range(0, 4);
        } while (beginPosY[randomNum] != 0);
        beginPosY[randomNum] = 1;
        ruler.beginPos = new Vector3(-ruler.direction.x * 4, -0.5f * randomNum, 0);

        // 根据ruler从工厂中生成一个飞碟
        GameObject disk = Singleton<DiskFactory>.Instance.GetDisk(ruler);
    
        // 设置飞碟的飞行动作
        actionManager.PlayDisk(disk, ruler.speed, ruler.direction);
    }
}
```

在`RoundController`的`FreeAllFactoryDisk`方法中，因为运动模式变化时飞碟的运动属性可能会不一样，点击返回按钮或重新开始按钮时也有可能有飞碟没有被销毁，影响下一次进行游戏，所以需要在点击这些按钮时，直接将所有飞碟都销毁，再去进行游戏：

```C#
// 释放所有工厂飞碟
public void FreeAllFactoryDisk() {
    GameObject[] obj = FindObjectsOfType(typeof(GameObject)) as GameObject[];
    foreach (GameObject g in obj) {
        if (g.gameObject.name == "Disk(Clone)(Clone)") {
            Singleton<DiskFactory>.Instance.FreeDisk(g);
        }
    }
}
```

### 效果截图

**游戏界面：**

![8.png](./Image/8.png)

**普通模式飞碟按运动学模式飞行，不会碰在一起：**

![9.png](./Image/9.png)

**普通模式飞碟按物理模式飞行，有可能相撞：**

![10.png](./Image/10.png)

**普通模式按照设置的N回合，这里设为2，游戏结束：**

![11.png](./Image/11.png)

**无尽模式，没有回合限制，可以一直进行下去：**

![12.png](./Image/12.png)
